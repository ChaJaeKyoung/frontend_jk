<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>built-in object</title>
  <script>
    // 2. 내장 객체(JS 기본 제공)
    // 자바스크립트 엔진에 내장되어 필요한 경우 생성하여 사용

    // 1) 날짜 정보 객체: 날짜와 시간에 대한 정보를 제공
    // 변수 = new Date();
    // 사용성이 떨어져서 다른 외부 라이브러리 사용을 추천

    // 오늘 날짜에 대한 정보를 가지고 있는 객체 생성
    const newDay = new Date();
    document.write(newDay, '<br>');
    const nowYear = newDay.getFullYear();
    const nowMonth = newDay.getMonth(); // date 객체는 현재 월보다 1 적게 나옴
    const nowDate = newDay.getDate();
    const nowDay = newDay.getDay(); // 0~6: 일~토 

    document.write('<h1>오늘 날짜 정보</h1>');
    document.write(`현재 연도: ${nowYear}<br>`);
    document.write(`현재 월: ${nowMonth}<br>`);
    document.write(`현재 일: ${nowDate}<br>`);
    document.write(`현재 요일: ${nowDay}<br>`);

    // 특정 날짜 정보를 갖는 날짜 객체 생성
    // new Date(연, 월, 일, 시, 분, 초, 밀리초);
    // 변수 = new Date(연, 월 - 1, 일);
    // 변수 = new Date('2023/12/31');
    // 변수 = new Date('2023-12-31');

    const someDay = new Date(2023, 11, 31);

    const theYear = someDay.getFullYear();
    const theMonth = someDay.getMonth(); // date 객체는 현재 월보다 1 적게 나옴
    const theDate = someDay.getDate();
    const theDay = someDay.getDay(); // 0~6: 일~토 

    document.write('<h1>오늘 날짜 정보</h1>');
    document.write(`현재 연도: ${theYear}<br>`);
    document.write(`현재 월: ${theMonth}<br>`);
    document.write(`현재 일: ${theDate}<br>`);
    document.write(`현재 요일: ${theDay}<br>`);

    // 특정 날짜까지 D-day 구하기
    // 남은 일 수 (밀리초) = 특정 날짜 객체 시간 - 현재 날짜 객체 시간
    // 1초 = 1000ms
    // 1분(60초) = 1000 * 60
    // 1시간(60분) = 1000 * 60 * 60
    // 1일(24시간) = 1000 * 60 * 60 * 24
    const classEndDate = new Date(2023, 2, 10); //2023년 3월 10일 객체 생성 (실제 월은 +1 한 값)
    const diffDate = classEndDate.getTime() - new Date().getTime();
    // getTime(): 1970년 1월 1일 0시 0분 0초로부터 지금까지 몇 ms가 지났는지..?
    const result = Math.ceil(diffDate / (1000 * 60 * 60 * 24)); // Math.ceil 소숫점 올림 내장 객체
    const test = Math.ceil(125.4);
    document.write('소숫점 올림 내장 객체 Math.ceil(125.4) 결과 값 : ' + test);
    document.write('<h1>오늘부터 종강까지 남은 날짜</h1>')
    document.write(`D-day: ${result}일 남았습니다.`)

    // 2) 수학 객체: 수학 관련 기능과 속성을 제공
    // 객체 생성을 하지 않고 사용 가능 => 정적(static) 객체
    // Math.메소드명();
    // Math.속성명;
    // 참조) Date같은 객체들은 새로운 변수에 담아서 사용해야 했지만 이런 정적 객체들은 그냥 사용하면 불러와진다!
    document.write('<h1>수학 객체 사용</h1>')
    const num = 2.1234;
    const maxNum = Math.max(10, 5, 8, 30); //최대값 
    document.write('최대값 : ' + maxNum, '<br>');
    const minNum = Math.min(10, 5, 8, 30); //최소값 
    document.write('최소값 : ' + minNum, '<br>');


    document.write('숫자 : ' + num, '<br>');
    const roundNum = Math.round(num); // 소수 첫째자리 반올림
    const floorNum = Math.floor(num); // 소수 첫째자리 반올림
    const ceilNum = Math.ceil(num); // 소수 첫째자리 반올림
    document.write('반올림 : ' + roundNum, '<br>');
    document.write('내림 : ' + floorNum, '<br>');
    document.write('올림 : ' + ceilNum, '<br>');

    const randomNum = Math.random(); // 0이상 1미만의 난수 발생 (실수값)
    document.write('랜덤난수(0<=x<1사이 실수값) : ' + randomNum, '<br>');
    document.write('파이값 : ' + Math.PI, '<br>');

    // random()을 이용하여 특정 범위의 랜덤한 정수값 구하기
    document.write('<h1>특정 범위의 랜덤한 정수값 구하기</h1>');
    // 0 <= Math.random() < 1 (0이상 1미만의 랜덤한 실수값)
    document.write(randomNum, '<br>');
    // 0 <= Math.random() * 10 < 10 (0이상 10미만의 랜덤한 실수값)
    document.write(randomNum * 10, '<br>');
    // 0 <= Math.floor(Math.random() * 10) < 10 (0이상 10미만의 랜덤한 정수값 => 0~9까지 랜덤 정수값)
    document.write(Math.floor(randomNum * 10), '<br>');
    // 1 <= Math.floor(Math.random() + 1 * 10) < 11 (1이상 11미만의 랜덤한 정수값 => 1~10까지 랜덤 정수값)
    document.write(Math.floor(randomNum * 10) + 1, '<br>');

    // 컴퓨터가 내려는 가위, 바위, 보 맞추기!
    document.write('<h1>컴퓨터 가위, 바위, 보 맞추기!</h1>');
    // const game = prompt('가위, 바위 , 보 중 선택하세요.','가위');
    // let gameNum;
    // switch (game) {
    //   case '가위':
    //     gameNum = 1;
    //     break;
    //   case '바위':
    //     gameNum = 2;
    //     break;
    //   case '보':
    //     gameNum = 3;
    //     break;

    //   default:
    //     alert('잘못 작성하셨습니다.');
    //     location.reload();
    //     break;
    // }
    // 컴퓨터는 1~3사이의 정수값 난수 발생

    const com = Math.floor(Math.random() * 3) + 1;
    // document.write('<img src="images/math_img_">' + com + '.jpg');
    document.write(`<img src="images/math_img_${com}.jpg">`);

    // if (com === gameNum) {
    //   document.write(`<img src="images/game_1.jpg">`);
    // } else {
    //   document.write(`<img src="images/game_2.jpg">`);
    // }
    // document.write('<br>');

    // 3) 배열 객체: 변수에는 하나의 데이터만 저장 가능, 배열에는 여러 개의 데이터를 순차적으로 하나의 저장소에 저장

    // 예: 학생 30명의 시험 점수를 저장하려면 30개의 변수가 필요한데, 배열을 이용하면 하나의 배열로 30개의 데이터를 저장하고 관리가 가능

    // 배열 객체 생성 3가지 방식
    // 첫번째 방식
    // 변수 = new Array(값1, 값2, 값3);

    // 두번째 방식
    // 변수 = new Array();
    // 변수[0] = 값1;
    // 변수[1] = 값2;
    // 변수[2] = 값3;

    // 세번째 방식
    // 변수 = [값1, 값2, 값3] => 리터럴 방식: 표기법 그대로에 값을 넣어서 생성하는 방식;

    // 배열에 접근하기
    // 배열의 인덱스는 0부터 시작
    // 변수[인덱스 번호] 로 접근 가능

    // 배열에 저장된 값 출력하기 (여러가지 방법 존재)
    const arr = [30, '따르릉', true, undefined]; //보통은 배열 안에 객체가 들어간다
    document.write('<h3>배열값 가져오기-1</h3>');
    document.write(arr[0], '<br>');// 하나씩 가져오기

    document.write('<h3>배열값 가져오기-2 for문</h3>');
    for (let i = 0; i < arr.length; i++) {// for문을 사용하여 가져오기
      document.write(arr[i], '<br>');
    }
    document.write('<h3>배열값 가져오기-3 for in 문</h3>');
    for (const i in arr) { //객체를 반복하는 문, 객체의 key값을 전부 가져오게 된다 (반복은 key값의 개수만큼)! 배열의 key값은 index가 된다
      document.write(arr[i], '<br>');
    }
    // (참고) for in 반복문은 배열이 아니라 객체에 사용할 때 최적화 되어 있어서 배열에 사용하면 객체 대비 10~100배 느림
    // 배열에 사용하는 것을 지양!
    document.write('<h3>배열값 가져오기-4 for of 문</h3>');
    for (const el of arr) {// ES6차
      document.write(el, '<br>');
    }
    document.write('<h3>배열값 가져오기-5 foreach 문</h3>');
    arr.forEach(function (el, index) {
      document.write(index, ' ', el, '<br>');
    });

    // 배열 객체의 메소드(1)
    const arr1 = ['사당', '교대', '방배', '강남'];
    const arr2 = ['신사', '압구정', '옥수'];

    let resultArr = arr1.join('-'); // 배열의 값을 지정한 문자로 연결하여 하나의 '문자열'로 반환 not'배열'
    console.log(resultArr);

    resultArr = arr1.concat(arr2); // 2개의 배열을 하나의 배열로 결합하여 '새로운' 배열로 반환 => 원본을 변경하는 것인지 새로운것을 반환하는 것인지 구분하여 알고있으면 좋음!
    console.log(resultArr);
    resultArr = arr2.concat(arr1);
    console.log(resultArr);

    resultArr = arr1.slice(1, 3); // 지정된 시작과 끝 위치 구간만큼 잘라내서 새로운 배열로 반환 (시작은 같고 입력한 끝값의 바로 전값까지 호출)
    console.log(resultArr);

    arr1.sort(); //배열의 값을 오름차순(알파벳 순)으로 정렬 (*원본 배열을 변경시킴 : 리엑트에서 중요!)
    console.log(arr1);
    arr2.reverse(); //배열의 순서를 반대로 바꿈 (*원본 배열을 변경시킴 : 리엑트에서 중요!)
    console.log(arr2);
    // 원본배열 비교
    resultArr = arr1.concat(arr2);
    console.log(resultArr);

    // 배열 객체의 메소드(2)
    const greenArr = ['교대', '방배', '강남'];
    const yellowArr = ['미금', '정자', '수서'];

    //splice(index, howmany, item1, ...) (*원본 배열을 변경시킴)
    greenArr.splice(2, 1, '서초', '역삼'); //splice 메소드 : 제거할요소 몇번째부터(index), 몇개를 제거할지(howmany) , 세번째 요소부터 추가 할 요소 입력
    console.log(greenArr);
    greenArr.splice(2, 0, '서초', '역삼'); //*응용* 제거할 요소를0 개하면 이후부터 추가만 가능!
    console.log(greenArr);

    //pop() : 배열의 마지막 요소를 제거, 제거된 요소를 반환 (*원본 배열을 변경시킴) 
    const popData = yellowArr.pop();
    console.log(popData);
    console.log(yellowArr);
    //shift() : 배열의 첫번째 요소를 제거, 제거된 요소를 반환 (*원본 배열을 변경시킴) 
    const shiftData = yellowArr.shift();
    console.log(shiftData);
    console.log(yellowArr); //최종 yellowArr 에는 정자밖에 남지 않았다.


    //push() : 배열의 끝에 새 요소를 추가(원본 배열이 변경됨)
    yellowArr.push(shiftData);
    console.log(yellowArr);
    //unshift() : 배열의 시작 부분에 새 요소를 추가(원본 배열이 변경됨)
    yellowArr.unshift(popData);
    console.log(yellowArr);

    // 배열 객체의 메소드(3) - 검색
    const fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];
    // indexOf(): 지정된 값의 첫번째 인덱스(위치)를 반환, 찾을 수 없는 경우 -1
    let index = fruits.indexOf('Apple');
    console.log(index);
    index = fruits.indexOf('Apple', 3); // 검색 시작 위치 지정 가능
    console.log(index);
    // includes(): 지정된 값이 포함된 경우 true, 포함되지 않은 경우 false (ES7차)
    console.log(fruits.includes('mango'));
    console.log(fruits.includes('Mango', 3)); // 검색 시작 위치 지정 가능

    // array.sort (비교 함수) : 숫자를 정렬하기 위한 비교 함수 필요
    // 비교 함수: function(a, b) { return a - b; }
    document.write('<h1>배열에서 숫자 데이터 정렬</h1>');
    const score = [40, 100, 65, 35, 9, 12];
    document.write(score.sort(), '<br>'); //알파벳순으로 정렬되어 우리가 원하는 값이 아닌 다른것이 나옴
    document.write(score.sort(function (a, b) { return a - b }), '<br>');
    // 오름차순 정렬(작은수부터)
    // 음수가 반환되면 a, b순으로 정렬 
    // 양수가 반환되면 b, a순으로 정렬
    // 0이 반환되면, 변화 없음 

    // 내림차순 정렬(큰수부터)
    // return값의 a ,b 위치를 바꾸면 된다
    // 정렬 알고리즘 google에 검색해라!

    // 4) 문자열 객체 : 문자형 데이터에 대한 정보를 제공하고 제어하는 메서드와 속성을 제공
    // 문자열 객체 생성 2가지 방식
    // 변수 = new String('문자');
    // 변수 = '문자'; => 리터럴 방식

    document.write('<h1>문자열 정보 출력하기</h1>');
    let text = 'Hello Thank you good luck to you';

    document.write('<h4>특정 문자 1개 추출</h4>');
    document.write(text.charAt(16), '<br>'); // 지정된 인덱스(위치)에 있는 문자를 반환

    document.write('<h4>문자열 검색</h4>');
    document.write('indexOF로 you를 검색 한 결과값: ' + text.indexOf('you'), '<br>');// 문자열에서 값이 처음 나타나는 위치를 반환, 찾을 수 없으면 -1
    document.write('indexOF로 you를 검색 한 결과값 + 검색시작 위치 지정: ' + text.indexOf('you', 16), '<br>'); //검색 시작 위치 지정
    document.write('lastindexOF로 you를 검색 한 결과값:' + text.lastIndexOf('you'), '<br>'); // 마지막부터 검색해도 인덱스 값은 같다
    document.write('lastindexOF로 you를 검색 한 결과값 + 검색시작 위치 지정:' + text.lastIndexOf('you', 25), '<br>');

    document.write('includes로 you를 검색 한 결과값: ' + text.includes('you'), '<br>');
    document.write('includes로 you를 검색 한 결과값 + 검색시작 위치 지정: ' + text.includes('you', 16), '<br>');

    document.write('<h4>문자열 추출</h4>');
    document.write(text.substr(21, 4), '<br>'); // 문자열의 일부-시작 index부터 지정한 길이만큼을(여기선 4개)- 추출
    document.write(text.substring(6, 12), '<br>'); // 6두 인덱스 (6번째 인덱스부터 끝 인덱스의 전까지의)사이의 문자를 추출
    console.log(text.substring(6, 12)); //공백까지 출력되기 때문에 콘솔창 이용하여 확인

    document.write('<h4>문자열 추출</h4>');
    document.write(text.replace('you', 'me'), '<br>'); // 첫번째 일치 항목을 찾아 교체된 새 문자열을 반환
    document.write(text.replace(/you/g, 'me'), '<br>'); // 모든 항목을 바꾸려면 정규표현식(정규식)-문자나 숫자를 검사할 때 짜는 식- 사용
    // /you[조건식 안넣고]/global g는 global의 약자 전역을 다 돌면서바꿔라
    document.write(text.toLowerCase(), '<br>'); // 소문자로 변환
    document.write(text.toUpperCase(), '<br>'); // 대문자로 변환

    document.write('<h4>문자열 길이</h4>');
    document.write(text.length, '<br>');

    document.write('<h4>문자열 배열로 쪼개기</h4>');
    const myArray = text.split(' '); //
    console.log(myArray);

    document.write('<h4>문자열 앞, 뒤 공백 제거</h4>');
    text = '      Hello World!       ';
    console.log(text.trim()); // 사용자가 로그인 할 때 아이디 입력시 앞뒤로 공백 입력한 것 까지 개발단에서 체크

    // 주민등록번호를 입력받은 후 정보가 노출되지 않도록 뒤의 여섯자리는 ******로 출력하세요.
    document.write('<h1>주민등록번호 마스킹</h1>');
    const userSsn = prompt('주민등록번호를 입력하세요.');
    const maskSsn = userSsn.substring(0, userSsn.length - 6) + '******';
    // '123456-1'234567 ''까지 잘라야함
    document.write(maskSsn, '<br>');

    // 사용자로부터 입력받은 이메일 주소 유효성 검사(정규표현식 안쓰는 경우)
    document.write('<h1>이메일 주소 유효성 검사</h1>');
    const userEmail = prompt('당신의 이메일 주소는?');
    const arrUrl = ['.co.kr', '.com', '.net', '.or.kr', 'go.kr'];

    let check1 = false;
    let check2 = false;

    if (userEmail.indexOf('@') > 0) {
      check1 = true;
      for (let i = 0; i < arrUrl.length; i++) {
        if (userEmail.indexOf(arrUrl[i]) > 0) {
          check2 = true;
        }
      }
    }

    if (check1 && check2) {
      document.write(userEmail);
    } else {
      alert('이메일 형식이 잘못되었습니다.');
    }


  </script>
</head>

<body>
  <h1 style="color: #00f">오늘부터 특정일까지 남은 실시간 시간</h1>
  <h2 class="d-day-count"></h2>
  <script>
    //(응용) D-day를 '일 시간 분 초'로 실시간 표시하기 
    const tomorrow = new Date(2023, 0, 6); //1월 5일 ~ 1월 6일까지의 시간
    const dDayCountEl = document.querySelector('.d-day-count');

    function counter() {
      const diff = tomorrow.getTime() - new Date().getTime();
      // document.write(diff, '밀리초<br>');

      // document.write(diff/ (1000 * 60 * 60 * 24), '일<br>');
      const dDay = Math.floor(diff / (1000 * 60 * 60 * 24)); // Math.floor(0.2121)->소숫점 뒤 버림

      // document.write(diff/ ((1000 * 60 * 60 )) % 24, '시간<br>');
      const dHour = Math.floor(diff / ((1000 * 60 * 60)) % 24);

      // document.write((diff/ (1000 * 60) % 60 ), '분<br>');
      const dMin = Math.floor(diff / (1000 * 60) % 60);

      // document.write((diff/ (1000) % 60 ), '초<br>');
      const dSec = Math.floor(diff / (1000) % 60);

      dDayCountEl.textContent = `${dDay}일 ${dHour}시간 ${dMin}분 ${dSec}초 남음`;
    }

    setInterval(counter, 1000); // setInterval(함수명,밀리초(1000ms =1s))

  </script>
</body>

</html>